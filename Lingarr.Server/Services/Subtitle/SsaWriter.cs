using Lingarr.Server.Interfaces.Services.Subtitle;
using Lingarr.Server.Models.FileSystem;

namespace Lingarr.Server.Services.Subtitle;

public class SsaWriter : ISubtitleWriter
{
    private string JoinLinesByWrapStyle(List<string> lines, SsaWrapStyle wrapStyle)
    {
        // Always join with \N as it's the standard in ASS/SSA
        // The wrap style affects how we handle the lines when reading/displaying
        // but when writing, we always use \N as the canonical format
        return string.Join("\\N", lines);
    }

    public async Task WriteStreamAsync(
        Stream stream, 
        IEnumerable<SubtitleItem> subtitleItems, 
        bool stripSubtitleFormatting)
    {
        var items = subtitleItems.ToList();
        if (!items.Any()) return;

        await using var writer = new StreamWriter(stream);
        var format = items[0].SsaFormat;

        if (format?.ScriptInfo.Any() == true)
        {
            await writer.WriteLineAsync("[Script Info]");
            await writer.WriteLineAsync("Title: Generated by Lingarr");
            foreach (var line in format.ScriptInfo)
            {
                if (line.Equals("[Script Info]", StringComparison.OrdinalIgnoreCase))
                {
                    continue;
                }
                if (line.StartsWith("Title:", StringComparison.OrdinalIgnoreCase))
                {
                    continue;
                }
                await writer.WriteLineAsync(line);
            }
        }
        else
        {
            await writer.WriteLineAsync("[Script Info]");
            await writer.WriteLineAsync("Title: Generated by Lingarr");
            await writer.WriteLineAsync("ScriptType: v4.00+");
            await writer.WriteLineAsync("WrapStyle: 0");
            await writer.WriteLineAsync("ScaledBorderAndShadow: yes");
            await writer.WriteLineAsync("YCbCr Matrix: None");
        }

        if (format?.Styles.Any() == true)
        {
            if (!stripSubtitleFormatting)
            {
                foreach (var line in format.Styles)
                {
                    await writer.WriteLineAsync(line);
                }
            }
            else
            {
                await writer.WriteLineAsync("[V4+ Styles]");
                await writer.WriteLineAsync("Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding");
                await writer.WriteLineAsync("Style: Default,Roboto Medium,26,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,1.3,0,2,20,20,23,1");
            }
        }
        
        // Write events section
        await writer.WriteLineAsync("[Events]");
        await writer.WriteLineAsync("Format: Marked, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text");

        foreach (var item in items)
        {
            var startTime = TimeSpan.FromMilliseconds(item.StartTime);
            var endTime = TimeSpan.FromMilliseconds(item.EndTime);
            var dialogue = item.SsaDialogue ?? new SsaDialogue();
            
            // Use original lines (with markup) or translated lines if available
            var linesToUse = item.TranslatedLines.Any() ? item.TranslatedLines : item.Lines;
                
            // Join lines according to wrap style
            var text = JoinLinesByWrapStyle(linesToUse, item.SsaFormat?.WrapStyle ?? SsaWrapStyle.None);
                
            if (stripSubtitleFormatting)
            {
                dialogue.Style = "Default";
                dialogue.Effect = string.Empty;
            }

            await writer.WriteLineAsync(
                $"Dialogue: {dialogue.Marked}," +
                $"{startTime:h\\:mm\\:ss\\.ff}," +
                $"{endTime:h\\:mm\\:ss\\.ff}," +
                $"{dialogue.Style}," +
                $"{dialogue.Name}," +
                $"{dialogue.MarginL}," +
                $"{dialogue.MarginR}," +
                $"{dialogue.MarginV}," +
                $"{dialogue.Effect}," +
                $"{text}");
        }
            
        await writer.FlushAsync();
    }
}